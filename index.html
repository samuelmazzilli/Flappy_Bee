<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RETRO BEE: CORRECT SPEED</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0; padding: 0;
            background: #202028;
            height: 100vh;
            display: flex; justify-content: center; align-items: center;
            font-family: 'Press Start 2P', cursive;
            touch-action: none;
            image-rendering: pixelated;
        }

        #game-boy {
            position: relative;
            width: 320px; height: 500px;
            background-color: #70c5ce;
            border: 15px solid #ddd;
            border-radius: 10px 10px 40px 10px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.2), 0 20px 40px rgba(0,0,0,0.5);
            overflow: hidden;
        }

        canvas { display: block; width: 100%; height: 100%; }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; align-items: center;
        }

        #score {
            margin-top: 40px; font-size: 40px; color: white;
            text-shadow: 4px 4px 0 #000; z-index: 10;
        }
        
        #speed-indicator {
            margin-top: 10px; font-size: 10px; color: #FF4500;
            text-shadow: 1px 1px 0 #fff; display: none;
            background: rgba(0,0,0,0.5); padding: 5px; border-radius: 5px;
        }

        #msg {
            position: absolute; top: 50%; width: 100%; text-align: center;
            color: #fff; font-size: 16px; line-height: 24px;
            text-shadow: 2px 2px 0 #000; transform: translateY(-50%);
            animation: blink 1s infinite;
        }

        @keyframes blink { 50% { opacity: 0; } }
    </style>
</head>
<body>

    <div id="game-boy">
        <div id="ui-layer">
            <div id="score">0</div>
            <div id="speed-indicator">MAX SPEED!</div>
            <div id="msg">PRESS TO START</div>
        </div>
        <canvas id="c"></canvas>
    </div>

    <script>
        const c = document.getElementById('c');
        const ctx = c.getContext('2d');
        const scoreEl = document.getElementById('score');
        const msgEl = document.getElementById('msg');
        const speedEl = document.getElementById('speed-indicator');

        c.width = 320;
        c.height = 500;
        ctx.imageSmoothingEnabled = false;

        // --- ASSETS ---
        const PALETTE = { 'Y': '#FFD700', 'B': '#222', 'W': '#FFF', 'R': '#D32F2F', 'T': 'transparent' };

        const BEE_F1 = [
            "      BB      ", "    BBWWBB    ", "   BYYWWYYB   ", "  BYYBWWBYYB  ",
            " BYYBYYYBYYBR ", " BYYBYYYBYYBR ", "  BYYBYYBYYB  ", "   BYYYYYYB   ", "    BBBBBB    "
        ];
        const BEE_F2 = [
            "    WW  WW    ", "   WWBWWBWW   ", "   BYYWWYYB   ", "  BYYBWWBYYB  ",
            " BYYBYYYBYYBR ", " BYYBYYYBYYBR ", "  BYYBYYBYYB  ", "   BYYYYYYB   ", "    BBBBBB    "
        ];

        function drawSprite(ctx, spriteMap, x, y, scale) {
            for (let row = 0; row < spriteMap.length; row++) {
                for (let col = 0; col < spriteMap[row].length; col++) {
                    let char = spriteMap[row][col];
                    if (char !== ' ') {
                        ctx.fillStyle = PALETTE[char] || PALETTE['Y'];
                        ctx.fillRect(x + col * scale, y + row * scale, scale, scale);
                    }
                }
            }
        }

        // --- VARIABILI DI GIOCO ---
        const GRAVITY = 0.25;
        const JUMP = -4.5;
        const GAP = 110;
        const PIXEL_SCALE = 3;
        
        const START_SPEED = 2;
        const MAX_SPEED = 5.0; 
        const PIPE_DISTANCE = 200; // Distanza FISSA in pixel tra i tubi

        let currentSpeed = START_SPEED;
        let frames = 0;
        let score = 0;
        let state = 'START';

        const bee = {
            x: 50, y: 200, w: 14 * PIXEL_SCALE, h: 9 * PIXEL_SCALE, velocity: 0,
            
            draw: function() {
                ctx.save();
                ctx.translate(this.x, this.y);
                let rot = 0;
                if (this.velocity < JUMP/2) rot = -25 * Math.PI/180;
                else if (this.velocity > 1) rot = 25 * Math.PI/180;
                ctx.translate(this.w/2, this.h/2); ctx.rotate(rot); ctx.translate(-this.w/2, -this.h/2);
                let sprite = (frames % 10 < 5 || this.velocity < 0) ? BEE_F2 : BEE_F1;
                drawSprite(ctx, sprite, 0, 0, PIXEL_SCALE);
                ctx.restore();
            },
            
            update: function() {
                this.velocity += GRAVITY;
                this.y += this.velocity;
                if (this.y + this.h >= c.height - 50) die();
            },
            flap: function() { this.velocity = JUMP; }
        };

        const pipes = {
            list: [],
            
            update: function() {
                // --- LOGICA SPAWN CORRETTA ---
                // Non guardiamo i frame, guardiamo la posizione dell'ultimo tubo.
                // Se non ci sono tubi O se l'ultimo tubo si è allontanato abbastanza (PIPE_DISTANCE)
                
                let spawnNeeded = false;
                
                if (this.list.length === 0) {
                    spawnNeeded = true; // Primo tubo
                } else {
                    let lastPipe = this.list[this.list.length - 1];
                    // Calcolo: Larghezza Canvas (320) - Posizione X ultimo tubo > Distanza voluta (200)
                    if (c.width - lastPipe.x >= PIPE_DISTANCE) {
                        spawnNeeded = true;
                    }
                }

                if (spawnNeeded) {
                    let min = 50;
                    let max = c.height - 50 - GAP - 50;
                    let y = Math.floor(Math.random() * (max - min) + min);
                    this.list.push({ x: c.width, y: y, passed: false });
                }

                for(let i=0; i<this.list.length; i++) {
                    let p = this.list[i];
                    p.x -= currentSpeed; // Si muovono più veloci, ma la distanza tra loro resta fissa!

                    let bx = bee.x + 4; let by = bee.y + 4;
                    let bw = bee.w - 8; let bh = bee.h - 8;
                    let pw = 50;

                    if (bx + bw > p.x && bx < p.x + pw && by < p.y) die();
                    if (bx + bw > p.x && bx < p.x + pw && by + bh > p.y + GAP) die();

                    if (p.x + pw < bx && !p.passed) {
                        score++; 
                        scoreEl.innerText = score; 
                        p.passed = true;
                        
                        // Increase Speed every 5 points
                        if (score % 5 === 0 && currentSpeed < MAX_SPEED) {
                            currentSpeed += 0.5; // Aumento più deciso
                            speedEl.style.display = 'block';
                            speedEl.innerText = "SPEED: " + currentSpeed.toFixed(1);
                            setTimeout(() => speedEl.style.display = 'none', 1000);
                        }
                    }

                    if (p.x + pw < 0) { this.list.shift(); i--; }
                }
            },

            draw: function() {
                for(let p of this.list) {
                    let pw = 50;
                    drawPipeRect(p.x, 0, pw, p.y);
                    drawPipeCap(p.x - 2, p.y - 20, pw + 4, 20);
                    let botY = p.y + GAP;
                    drawPipeRect(p.x, botY, pw, c.height - 50 - botY);
                    drawPipeCap(p.x - 2, botY, pw + 4, 20);
                }
            }
        };

        function drawPipeRect(x, y, w, h) {
            ctx.fillStyle = '#74bf2e'; ctx.fillRect(x, y, w, h);
            ctx.fillStyle = '#9ce659'; ctx.fillRect(x + 5, y, 5, h);
            ctx.fillStyle = '#558c22'; ctx.fillRect(x + w - 5, y, 5, h);
            ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.strokeRect(x, y, w, h);
        }
        function drawPipeCap(x, y, w, h) {
            ctx.fillStyle = '#74bf2e'; ctx.fillRect(x, y, w, h);
            ctx.fillStyle = '#9ce659'; ctx.fillRect(x + 5, y, 5, h);
            ctx.fillStyle = '#558c22'; ctx.fillRect(x + w - 5, y, 5, h);
            ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.strokeRect(x, y, w, h);
        }

        const ground = {
            off: 0,
            draw: function() {
                let h = 50; let y = c.height - h;
                ctx.fillStyle = '#ded895'; ctx.fillRect(0, y, c.width, h);
                ctx.fillStyle = '#73bf2e'; ctx.fillRect(0, y, c.width, 10);
                ctx.beginPath(); ctx.moveTo(0, y+10); ctx.lineTo(c.width, y+10); 
                ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.stroke();
                
                ctx.strokeStyle = '#cbb968'; ctx.lineWidth = 2;
                for(let i = -20; i < c.width; i+=20) {
                    ctx.beginPath();
                    ctx.moveTo(i - this.off, y + 15); ctx.lineTo(i - this.off - 10, y + 45); ctx.stroke();
                }
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(c.width, y); 
                ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.stroke();
            },
            update: function() {
                this.off = (this.off + currentSpeed) % 20; 
            }
        };

        function loop() {
            if (state === 'PLAY') {
                bee.update(); pipes.update(); ground.update(); frames++;
            } else if (state === 'START') {
                bee.y = 200 + Math.sin(Date.now()/200) * 5; ground.update();
            }

            ctx.fillStyle = '#70c5ce'; ctx.fillRect(0,0,c.width,c.height);
            drawSprite(ctx, ["  WW  ", " WWWWW ", "WWWWWWW"], 50, 100, 4);
            drawSprite(ctx, ["  WW  ", " WWWWW ", "WWWWWWW"], 200, 150, 4);

            pipes.draw(); ground.draw(); bee.draw();

            requestAnimationFrame(loop);
        }

        function die() {
            if (state === 'OVER') return;
            state = 'OVER';
            msgEl.innerText = "GAME OVER\nSCORE: " + score + "\nPRESS TO RESTART";
            msgEl.style.display = 'block';
            speedEl.style.display = 'none';
        }

        function reset() {
            bee.y = 200; bee.velocity = 0;
            pipes.list = []; score = 0; scoreEl.innerText = 0;
            currentSpeed = START_SPEED; // Reset Speed
            state = 'START';
            msgEl.innerText = "PRESS TO START";
        }

        function input() {
            if (state === 'START') { state = 'PLAY'; msgEl.style.display = 'none'; bee.flap(); }
            else if (state === 'PLAY') { bee.flap(); }
            else if (state === 'OVER') { reset(); }
        }

        window.addEventListener('mousedown', input);
        window.addEventListener('keydown', e => { if(e.code === 'Space') input(); });
        window.addEventListener('touchstart', e => { e.preventDefault(); input(); }, {passive:false});

        loop();
    </script>
</body>
</html>
